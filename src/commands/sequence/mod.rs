// pub mod make_arithmetic;
// pub mod sum;
// pub mod terms;
// pub mod toformula;

use async_trait::async_trait;
use calcbot_attrs::Info;
use itertools::Itertools;
use crate::{
    arg_parse::{MinVec, parse_args_full},
    commands::{Command, Context, Info},
    database::Database,
    error::Error,
    global::State,
};
use std::sync::Arc;
use tokio::sync::Mutex;

/// Marker to build a difference table.
struct Difference;

/// Marker to build a factor table.
struct Factor;

trait TableKind {
    /// Returns the value change from `a` to `b`.
    fn change(values: (f64, f64)) -> f64;

    /// Applies the operation to `a` and `b`.
    fn apply(values: (f64, f64)) -> f64;

    /// Builds a table for the given sequence. Return [`None`] if the sequence is determined to be
    /// too unstable, i.e. there is not enough information to find a common difference or factor.
    fn make_table(sequence: Vec<f64>) -> Option<Vec<Vec<f64>>> {
        let out: Vec<_> = std::iter::successors(
            Some(sequence),
            |row| if row.iter().all_equal() {
                None
            } else {
                Some(
                    row.iter()
                        .zip(row.iter().skip(1))
                        .map(|(&a, &b)| (a, b))
                        .map(Self::change)
                        .collect()
                )
            },
        )
            .collect();

        let last_row = out.last()?;
        if last_row.len() <= 1 {
            return None;
        }

        Some(out)
    }

    /// Extends a table generated by [`TableKind::make_table`] by one column.
    fn extend_table(mut table: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
        for i in (0..table.len()).rev().skip(1) { // skip common difference row
            let [below_row, this_row] = table.get_disjoint_mut([i + 1, i]).unwrap();
            let new_elem = Self::apply((*this_row.last().unwrap(), *below_row.last().unwrap()));
            this_row.push(new_elem);
        }
        table
    }
}

/// Extract the order, constant difference, and next term from a difference table.
fn get_difference_info(change_table: Vec<Vec<f64>>) -> (usize, f64, f64) {
    let order = change_table.len() - 1;
    let constant = change_table.last().unwrap()[0];
    let next_term = change_table[0].last().unwrap();
    (order, constant, *next_term)
}

impl TableKind for Difference {
    fn change((a, b): (f64, f64)) -> f64 {
        b - a
    }

    fn apply((a, b): (f64, f64)) -> f64 {
        a + b
    }
}

impl TableKind for Factor {
    fn change((a, b): (f64, f64)) -> f64 {
        b / a
    }

    fn apply((a, b): (f64, f64)) -> f64 {
        a * b
    }
}

/// Predicts the next number in an nth-order (arithmetic, quadratic, cubic, etc.) or geometric
/// sequence, given some terms of the sequence.
///
/// There are extra commands for working with sequences. See the `Children commands` section above.
#[derive(Clone, Info)]
#[info(
    category = "Calculate",
    aliases = ["sequence", "seq", "s"],
    syntax = ["<term> <term> ..."],
    examples = ["1 3 6 10 15"],
    children = [
        // make_arithmetic::MakeArithmetic,
        // sum::Sum,
        // terms::Terms,
        // toformula::ToFormula,
    ],
)]
pub struct Sequence;

#[async_trait]
impl Command for Sequence {
    async fn execute<'c>(
        &'c self,
        state: &Arc<State>,
        _database: &Arc<Mutex<Database>>,
        ctxt: Context<'c>,
    ) -> Result<(), Error> {
        let parsed = parse_args_full::<MinVec<_, 2>>(ctxt.raw_input)
            .map_err(|err| if matches!(err, Error::NoArgument) {
                self.info().build_embed(ctxt.prefix).into()
            } else {
                err
            })?;

        if let Some(diff_table) = Difference::make_table(parsed.0.clone()) {
            let diff_table = Difference::extend_table(diff_table);
            let (order, constant, next_term) = get_difference_info(diff_table);
            let common_str = format!("`Δ^{order} a_n = {constant}`");

            ctxt.trigger.reply(&state.http)
                .content(&format!("**Next term in sequence** ({common_str})\n{next_term}"))
                .await?;
        } else if let Some(factor_table) = Factor::make_table(parsed.0) {
            let factor_table = Factor::extend_table(factor_table);
            let (order, constant, next_term) = get_difference_info(factor_table);
            let common_str = format!("`Δ^{order} log(a_n) = log({constant})`");

            ctxt.trigger.reply(&state.http)
                .content(&format!("**Next term in sequence** ({common_str})\n{next_term}"))
                .await?;
        } else {
            // any polynomial can fit any sequence, but it doesn't mean the sequence is stable
            ctxt.trigger.reply(&state.http)
                .content(&format!("**Unable to determine the next term in the sequence.** I couldn't find a repeating finite difference or factor between the terms. Try extending the sequence."))
                .await?;
        };

        Ok(())
    }
}
